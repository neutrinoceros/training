
# Hands-on tutorial


## Requirements

!!! info

    If you've used git on your current machine in the past, skip this section.

make sure `git` is available on your system
```
$ which git
```
if not, follow [official docs](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)

Next, you'll want to configure git globally
```
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

## Additional recommendations

It also recommended to associate a terminal-based editor of your choice to `git`.
For instance this is how you'd set `nano`
```
$ git config --global core.editor nano
```
This is because some advanced sub-commands require an editor, and its preferable
to know that you are confortable with the one you get (otherwise it may default
to `vi`, which is infamously hard to exit when you've never used it).

It it recommended that to sign up on GitHub.

## Getting started (first commits)
!!! info

    In this section we will create a dummy project *from scratch*. You can use an
    actual project of yours instead if you feel confortable to.



Create a new project (or *repository* from now on)
```
$ mkdir my-project
$ cd my-project
$ git init
```
We now have an empty project: no files are currently being *tracked*, and we
have no history. Let's introduce a very useful command that will help us
visualize the current state of the repository : `git status`.

!!! info

    While the output of `git status` calls is included in the page, it is strongly
    recommended to run these yourself in a terminal.

<details><summary> git status </summary>
```

On branch main

No commits yet

nothing to commit (create/copy files and use "git add" to track)
```

</details>

Now let's start by creating some file
```
$ echo "Hello world !" > README.txt
```

and see how this affects the state

<details><summary> git status </summary>
```
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    README.txt

nothing added to commit but untracked files present (use "git add" to track)
```
</details>

We see that the file we just created is currently *untracked*, meaning its evolution is not followed by `git`.
The output of `git status` also contains a helpful hint at what to do next to start tracking it:

```
$ git add README.txt
```
<details><summary> git status </summary>
```
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
    new file:   README.txt
```
</details>

We see that `README.txt` is now being *tracked* by the system, but it is not *commited* yet, meaning we haven't created an actual *version* (or *commit*, from now on) in the history. So let's do just that

```
$ git commit -m "Add README.txt"
```

with `-m`, with associate a *message* to our commit.
The message should be *concise* yet *meaningful* and describe the change that was performed.

<details><summary> git status </summary>
```
On branch main
nothing to commit, working tree clean
```
</details>

Hurray ! Now `README.txt` is being tracked by `git` *and* we have a history that should look something like this
(hey, one has to start _somewhere_)

<p align="center">
<img title="one lonely commit" src="https://raw.githubusercontent.com/neutrinoceros/training/git_intro/git/intro/docs/single_commit_history.png">
</p>

More interestingly, we can now visualize our brand new history with `git log`, which should output something like this
```
commit 956206c5db49848047ef45161ed9e457dcb5f9a8 (HEAD -> main)
Author: John Doe <johndoe@example.com>
Date:   Mon Nov 28 15:22:38 2022 +0100

    Add README.txt
```

There we see all our most recent commits (just one in this case).

!!! note

    In addition to the rest of our metadata (author, date, commit message), each commit is uniquely identified by a [hash](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms)
    (`956206c5db49848047ef45161ed9e457dcb5f9a8` in the example above). This is an alpha-numeric string
    that is generated by a deterministic but chaotic algorithm, which outputs are *very likely* to be unique
    within a project.

    We can also see that `HEAD` (which represents our current position in the history) points to this commit, as does the `main` branch (more on that later).

!!! abstract "Excercise"

    Repeat the last few steps: add new files to the index, and commit them


!!! bug "TODO"
    demonstrate how to modify already tracked files (into `git add -u`)


Now we should have a more detailed history

<p align="center">
<img title="one lonely branch" src="https://raw.githubusercontent.com/neutrinoceros/training/git_intro/git/intro/docs/single_branch_linear_history_annotated_1.png">
</p>




## Going back in time

!!! info

    In this section we will learn how to *navigate* the history, i.e., visiting previous versions of the project using `git checkout`

`git checkout` is the go-to command to **change the position of `HEAD` on the history tree**.

<p align="center">
<img title="one lonely branch" src="https://raw.githubusercontent.com/neutrinoceros/training/git_intro/git/intro/docs/single_branch_linear_history_annotated_2.png">
</p>


## Branching out

!!! info

    In this section we will learn how to use history *branches*, which are a central and powerful concept
    at the heart of most development workflows.


<p align="center">
<img title="thinking in branches (HEAD on branch)" src="https://raw.githubusercontent.com/neutrinoceros/training/git_intro/git/intro/docs/multi_branch_history_annotated_1.png">
</p>

<p align="center">
<img title="thinking in branches (HEAD on main)" src="https://raw.githubusercontent.com/neutrinoceros/training/git_intro/git/intro/docs/multi_branch_history_annotated_2.png">
</p>
